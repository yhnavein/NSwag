/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v{{ ToolchainVersion }} (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

{{ ExtensionCodeImport -}}
{% if ImportRequiredTypes -%}
{%     if GenerateClientClasses -%}
{%         if IsAngular -%}

import { Injectable, Inject, Optional, {{ InjectionTokenType }} } from '@angular/core';
import { HttpClient } from "@angular/common/http";
import { Observable } from 'rxjs';

import 'rxjs/add/operator/map';
import 'rxjs/add/operator/debounceTime';
import 'rxjs/add/operator/distinctUntilChanged';
import 'rxjs/add/operator/switchMap';
import 'rxjs/add/operator/do';
import 'rxjs/add/operator/finally';
{%         endif -%}
{%         if IsAurelia -%}

import { inject } from 'aurelia-framework';
import { HttpClient, RequestInit } from 'aurelia-fetch-client';
{%         endif -%}
{%         if IsAngularJS -%}

import * as ng from 'angular';
{%         endif -%}
{%         if IsKnockout -%}

import * as ko from 'knockout';
{%         endif -%}
{%         if IsJQuery -%}

import * as jQuery from 'jquery';
{%         endif -%}
{%     endif -%}
{%     if RequiresMomentJS -%}

import * as moment from 'moment';
{%     endif -%}
{% endif -%}

{% if HasModuleName -%}
export module {{ ModuleName }} {
{% endif -%}
{% if HasNamespace -%}
namespace {{ Namespace }} {
{% endif -%}
{% if GenerateClientClasses and IsAngular -%}
export const {{ BaseUrlTokenName }} = new {{ InjectionTokenType }}{% if InjectionTokenType == "InjectionToken" %}<string>{% endif %}('{{ BaseUrlTokenName }}');

{% endif -%}

class BaseClient {% if HasBaseClass %} extends {{ BaseClass }} {% endif %}{
  protected baseUrl: string;

  constructor(private http: HttpClient, baseUrl?: string) {
    this.baseUrl = baseUrl;
  }
  
  protected $get<T>(url: string): Observable<T> {
    return this.http.get<T>(this.baseUrl + url);
  }

  protected $getAll<T>(url: string): Observable<T[]> {
    return this.http.get<T[]>(this.baseUrl + url);
  }

  protected $delete<T>(url: string): Observable<T> {
    return this.http.delete<T>(this.baseUrl + url);
  }

  protected $post<T>(url: string, data: any = null): Observable<T> {
    return this.http.post<T>(this.baseUrl + url, data);
  }

  protected $put<T>(url: string, data: any): Observable<T> {
    return this.http.put<T>(this.baseUrl + url, data);
  }

  protected $patch<T>(url: string, data: any): Observable<T> {
    return this.http.patch<T>(this.baseUrl + url, data);
  }
}

{{ ExtensionCodeTop }}

{{ Clients }}

{{ Types }}

{% if WrapResponses and GenerateResponseClasses -%}
{%     for responseClassName in ResponseClassNames -%}
export class {{ responseClassName }}<TResult> {
  status: number;
  headers: { [key: string]: any; };
  result: TResult;

  constructor(status: number, headers: { [key: string]: any; }, result: TResult)
  {
    this.status = status;
    this.headers = headers;
    this.result = result;
  }
}

{%     endfor -%}
{% endif -%}
{% if RequiresFileParameterInterface -%}
export interface FileParameter {
  data: any;
  fileName: string;
}

{% endif -%}
{% if RequiresFileResponseInterface -%}
export interface FileResponse {
  data: Blob;
  status: number;
  fileName?: string;
  headers?: { [name: string]: any };
}

{% endif -%}

{{ ExtensionCodeBottom }}
{% if HasNamespace -%}
}
{% endif -%}
{% if HasModuleName -%}
}
{% endif -%}
