/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v{{ ToolchainVersion }} (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

{{ ExtensionCodeImport -}}
{% if ImportRequiredTypes -%}
{%     if GenerateClientClasses -%}
{%         if IsAngular -%}

import { Injectable, Inject, Optional, {{ InjectionTokenType }} } from '@angular/core';
import { Http, Headers, ResponseContentType{% if UseTransformOptionsMethod %}, RequestOptionsArgs{% endif %} } from '@angular/http';
{%         endif -%}
{%         if IsAurelia -%}

import { inject } from 'aurelia-framework';
import { HttpClient, RequestInit } from 'aurelia-fetch-client';
{%         endif -%}
{%         if IsAngularJS -%}

import * as ng from 'angular';
{%         endif -%}
{%         if IsKnockout -%}

import * as ko from 'knockout';
{%         endif -%}
{%         if IsJQuery -%}

import * as jQuery from 'jquery';
{%         endif -%}
{%     endif -%}
{%     if RequiresMomentJS -%}

import * as moment from 'moment';
{%     endif -%}
{% endif -%}

{% if HasModuleName -%}
export module {{ ModuleName }} {
{% endif -%}
{% if HasNamespace -%}
namespace {{ Namespace }} {
{% endif -%}
{% if GenerateClientClasses and IsAngular -%}
export const {{ BaseUrlTokenName }} = new {{ InjectionTokenType }}{% if InjectionTokenType == "InjectionToken" %}<string>{% endif %}('{{ BaseUrlTokenName }}');

{% endif -%}

class BaseClient {% if HasBaseClass %} extends {{ BaseClass }} {% endif %}{
  protected baseUrl: string;

  constructor(@Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.baseUrl = baseUrl;
  }

  protected $get<T>(url: string): Promise<T> {
    const opts = <RequestInit>{
      method: "GET",
      headers: <HeadersInit>{
        "Content-Type": "application/json",
      }
    };

    return fetch(this.baseUrl + url, opts)
      .then((_response: Response) => this.processSingle<T>(_response));
  }

  protected $getAll<T>(url: string): Promise<T[]> {
    const opts = <RequestInit>{
      method: "GET",
      headers: <HeadersInit>{
        "Content-Type": "application/json",
      }
    };

    return fetch(this.baseUrl + url, opts)
      .then((_response: Response) => this.processMany<T>(_response));
  }

  protected $delete<T>(url: string): Promise<any> {
    const opts = <RequestInit>{
      method: "DELETE",
      headers: <HeadersInit>{
        "Content-Type": "application/json",
      }
    };

    return fetch(this.baseUrl + url, opts)
      .then((_response: Response) => this.processSingle<T>(_response));
  }

  protected $post<T>(url: string, data: any = null): Promise<any> {
    const opts = <RequestInit>{
      body: data && JSON.stringify(data),
      method: "POST",
      headers: <HeadersInit>{
        "Content-Type": "application/json",
      }
    };

    return fetch(this.baseUrl + url, opts)
      .then((_response: Response) => this.processSingle<T>(_response));
  }

  protected $put<T>(url: string, data: any): Promise<any> {
    const opts = <RequestInit>{
      body: JSON.stringify(data),
      method: "PUT",
      headers: <HeadersInit>{
        "Content-Type": "application/json",
      }
    };

    return fetch(this.baseUrl + url, opts)
      .then((_response: Response) => this.processSingle<T>(_response));
  }

  protected $patch<T>(url: string, data: any): Promise<any> {
    const opts = <RequestInit>{
      body: JSON.stringify(data),
      method: "PATCH",
      headers: <HeadersInit>{
        "Content-Type": "application/json",
      }
    };

    return fetch(this.baseUrl + url, opts)
      .then((_response: Response) => this.processSingle<T>(_response));
  }

  protected processSingle<T>(response: any): Promise<T> {
    const status = response.status;

    if (status === 200 || status === 204) {
      return response.json();
    }
    else {
      return response.text().then((msg) => Promise.reject(msg || "error_no_callback_for_the_received_http_status"));
    }
  }

  protected processMany<T>(response: any): Promise<T[]> {
    const status = response.status;

    if (status === 200 || status === 204) {
      return response.json();
    }
    else {
      return response.text().then((msg) => Promise.reject(msg || "error_no_callback_for_the_received_http_status"));
    }
  }
}

{{ ExtensionCodeTop }}

{{ Clients }}

{{ Types }}

{% if WrapResponses and GenerateResponseClasses -%}
{%     for responseClassName in ResponseClassNames -%}
export class {{ responseClassName }}<TResult> {
  status: number;
  headers: { [key: string]: any; };
  result: TResult;

  constructor(status: number, headers: { [key: string]: any; }, result: TResult)
  {
    this.status = status;
    this.headers = headers;
    this.result = result;
  }
}

{%     endfor -%}
{% endif -%}
{% if RequiresFileParameterInterface -%}
export interface FileParameter {
  data: any;
  fileName: string;
}

{% endif -%}
{% if RequiresFileResponseInterface -%}
export interface FileResponse {
  data: Blob;
  status: number;
  fileName?: string;
  headers?: { [name: string]: any };
}

{% endif -%}

{{ ExtensionCodeBottom }}
{% if HasNamespace -%}
}
{% endif -%}
{% if HasModuleName -%}
}
{% endif -%}
