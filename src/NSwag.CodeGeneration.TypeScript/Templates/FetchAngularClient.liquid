
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

class BaseClient {% if HasBaseClass %}extends {{ BaseClass }} {% endif %} {
  protected http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
  protected baseUrl: string;

  constructor( @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.baseUrl = baseUrl;
  }

  protected $get<T>(url: string): Promise<T> {
    const opts = <RequestInit>{
      method: "GET",
      headers: new Headers({
        "Content-Type": "application/json",
      })
    };

    return this.http.fetch(this.baseUrl + url, opts)
      .then((_response: Response) => this.processSingle<T>(_response));
  }

  protected $getAll<T>(url: string): Promise<T[]> {
    const opts = <RequestInit>{
      method: "GET",
      headers: new Headers({
        "Content-Type": "application/json",
      })
    };

    return this.http.fetch(this.baseUrl + url, opts)
      .then((_response: Response) => this.processMany<T>(_response));
  }

  protected $delete<T>(url: string): Promise<any> {
    const opts = <RequestInit>{
      method: "DELETE",
      headers: new Headers({
        "Content-Type": "application/json",
      })
    };

    return this.http.fetch(this.baseUrl + url, opts)
      .then((_response: Response) => this.processSingle<T>(_response));
  }

  protected $post<T>(url: string, data: any): Promise<any> {
    const opts = <RequestInit>{
      body: JSON.stringify(data),
      method: "POST",
      headers: new Headers({
        "Content-Type": "application/json",
      })
    };

    return this.http.fetch(this.baseUrl + url, opts)
      .then((_response: Response) => this.processSingle<T>(_response));
  }

  protected $put<T>(url: string, data: any): Promise<any> {
    const opts = <RequestInit>{
      body: JSON.stringify(data),
      method: "PUT",
      headers: new Headers({
        "Content-Type": "application/json",
      })
    };

    return this.http.fetch(this.baseUrl + url, opts)
      .then((_response: Response) => this.processSingle<T>(_response));
  }

  protected $patch<T>(url: string, data: any): Promise<any> {
    const opts = <RequestInit>{
      body: JSON.stringify(data),
      method: "PATCH",
      headers: new Headers({
        "Content-Type": "application/json",
      })
    };

    return this.http.fetch(this.baseUrl + url, opts)
      .then((_response: Response) => this.processSingle<T>(_response));
  }

  protected processSingle<T>(response: any): T {
    var data = response.data;
    var status = response.status;

    if (status === 200 || status === 204) {
      return data;
    }
    else {
      throw "error_no_callback_for_the_received_http_status";
    }
  }

  protected processMany<T>(response: any): T[] {
    var data = response.data;
    var status = response.status;

    if (status === 200 || status === 204) {
      return data;
    }
    else {
      throw "error_no_callback_for_the_received_http_status";
    }
  }
}

{% if HasOperations -%}
{% if GenerateClientInterfaces -%}
export interface I{{ Class }} {
{%     for operation in Operations -%}
    {% template Client.Method.Documentation %}
    {{ operation.MethodAccessModifier }}{{ operation.ActualOperationName }}({% for parameter in operation.Parameters %}{{ parameter.VariableName }}{% if GenerateOptionalParameters and parameter.IsOptional %}?{% endif %}: {{ parameter.Type }}{{ parameter.TypePostfix }}{% if parameter.IsLast == false %}, {% endif %}{% endfor %}): Promise<{{ operation.ResultType }}>;
{%     endfor -%}}
{% endif -%}

export class {{ Class }} extends BaseClient {% if GenerateClientInterfaces %}implements I{{ Class }} {% endif %}{

{% for operation in Operations -%}

    {% template Client.Method.Documentation %}
    {{ operation.MethodAccessModifier }}{{ operation.ActualOperationName }}({% for parameter in operation.Parameters %}{{ parameter.VariableName }}{% if GenerateOptionalParameters and parameter.IsOptional %}?{% endif %}: {{ parameter.Type }}{{ parameter.TypePostfix }}{% if parameter.IsLast == false %}, {% endif %}{% endfor %}): Promise<{{ operation.ResultType }}> {
        const url = "{{ operation.Path }}{% if operation.HasQueryParameters %}?{% endif %}";

        return this.$post(url, vm);
    }

{% endfor -%}
}
{% endif -%}